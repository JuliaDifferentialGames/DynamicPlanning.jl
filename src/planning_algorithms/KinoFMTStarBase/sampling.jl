# ============================================================================ #
# Sample Generation
# ============================================================================ #

using DifferentialEquations
using Random
using LinearAlgebra


"""
    generate_kinodynamic_samples(problem, params, control_duration)

Generate uniform samples in the state space for Kinodynamic FMT*.

This is the KEY difference from RRT-like approaches:
- Samples are uniformly distributed in FREE state space
- NOT generated by forward propagation
- Start node is always included
- Goal region should be reachable by the sample set
"""
function generate_kinodynamic_samples(
    problem::TPBVP, params::PlanningAlgorithm, control_duration::Float64
)
    # Extract types
    T = typeof(problem.x0)
    U = typeof(zeros(problem.m))
    
    # State bounds
    state_lower, state_upper = get_bounds(problem, :x)
    
    # Validation function
    valid_state(state) = is_state_collision_free(state, problem, state_lower, state_upper)
    
    # Initialize sample set
    samples = KinoNode{T, U}[]
    
    # 1. Always include start node
    start_node = KinoNode(problem.x0, zeros(problem.m), 0.0)
    start_node.cost = 0.0
    push!(samples, start_node)
    
    # 2. Generate N-1 uniform samples in free state space
    sample_count = 1
    attempts = 0
    max_attempts = params.n_samples #* 100
    
    while sample_count < params.n_samples && attempts < max_attempts
        attempts += 1
        
        # CRITICAL: Sample uniformly in state space (not by propagation!)
        x_sample = sample_uniform_state(state_lower, state_upper)
        
        # Only accept collision-free states
        if valid_state(x_sample)
            node = KinoNode(x_sample, zeros(problem.m), 0.0)
            push!(samples, node)
            sample_count += 1
        end
    end
    
    @info "Generated $sample_count uniform kinodynamic samples in $attempts attempts"
    return samples
end



"""
    sample_uniform_state(lower, upper)

Sample uniformly in the state space.
For SE(2): uniform in (x, y, θ)
"""
function sample_uniform_state(lower::Vector, upper::Vector)
    return lower .+ rand(length(lower)) .* (upper .- lower)
end


"""
    is_state_collision_free(state, problem, state_lower, state_upper)

Check if a single state is collision-free (no trajectory checking).
"""
function is_state_collision_free(state::Vector, problem::TPBVP, 
                                  state_lower::Vector, state_upper::Vector)
    # Check bounds
    if any(state .< state_lower) || any(state .> state_upper)
        return false
    end
    
    # Check workspace bounds
    if !(state[1:2] ∈ problem.workspace.bounds)
        return false
    end
    
    # Check obstacles
    for obs in problem.workspace.obstacles
        if state[1:2] ∈ obs
            return false
        end
    end
    
    return true
end

"""
Collision and bound checking
"""
function trajectory_validation(traj::Vector, problem::TPBVP, state_lower::Vector, state_upper::Vector)

    for state ∈ traj 
        # Check if within state constraints 
        if (any(state < state_lower) || any(state > state_upper))
            return false 
        end

        # Check if in the workspace 
        if (!(state[1:2] ∈ problem.workspace.bounds))
            return false 
        end

        # Check if not hitting obstacles
        for obs ∈ problem.workspace.obstacles
            if (state[1:2] ∈ obs)
                return false
            end
        end
    end

    return true
end




function simulate_forward(x0::Vector,
    control,
    dynamics::Function,
    duration::Float64;
    n_steps::Int = 20)

    # Create control interp object 
    t = collect(0.0:duration/(n_steps-1):duration)
    ctrl = [linear_interpolation(t, control[i]*ones(size(t))) for i ∈ 1:2]

    prob = ODEProblem(dynamics, x0, (0.0, duration), ctrl)
    sol = solve(prob, Tsit5(), adaptive=false, dt = duration / (n_steps - 1))

    trajectory = [sol.u[i] for i in 1:length(sol.u)]
    final_state = sol.u[end]

    return trajectory, final_state
    
end


function get_bounds(problem::TPBVP, type::Symbol)
    contraints = problem.robot.constraints 

    for con in contraints 
        if con isa BoxConstraint && con.type == type
            return con.lower, con.upper
        end
    end
end


function sample_control(lower::Vector, upper::Vector)
    return lower .+ rand(length(lower)) .* (upper .- lower)
end


function sample_SE2(r::Float64, lower::Vector, upper::Vector; center::Tuple{<:Real,<:Real}=(0, 0))
    # Position
    u = rand()
    v = rand()
    R = r .* sqrt.(u)
    ψ = 2π .* v
    x = R .* cos.(ψ) .+ center[1]
    y = R .* sin.(ψ) .+ center[2]

    # Angle
    θ = lower[3] + rand() * (upper[3] - lower[3])

    return [x, y, θ]
end